---
layout: post
title: P000. The Decision of the New "Nervous System" for the Drone
---
The flight controller of a drone works like a nervous system. It senses the external changes, then understands them and makes decission, and finally reacts to them by adjusting its own state, so that it can adapt itself to the ever-changing world.

In the middle school, I've learnt some interesting facts about the nervous system of human beings. It is said that the brain only handles the complex behaviours like talking or solving a mathmatical problem. A lot of other simple behaviours or survival reactions are handled by the spinal cord instead of the brain, because spinal cord can react faster than the brain. In this way, human beings are able to get out of dangerous situation as fast as possible, while still keeping the abilities to finish complex tasks.

According these facts, it seems that Beaglebone Black could be a perfect solution for some use cases like drone controller. It has a powerful CPU acting like the brain, which can perform computation very efficiently, so that the drone is able to finish some complex tasks like auto-piloting with graphics recognition. In the meanwhile, it also comes with two PRUs acting like spinal cord. They don't have an operating system as an extra layer running above it, so they are perfect for doing some "real-time" tasks like balance keeping.

However, this kind of naive thoughts only works in the imagination world. In the reality, it is only the beginning of the struggling.

5 days ago I have purchased the Beaglebone Black for around 50 Euros. Immediately after I've received it, I started with PRU programming. Until I decided to return it, I've put almost all my free time and efforts into it, but the outcome just didn't compensate the efforts at all.

![post-image]({{ "/assets/img/2020-05-21-beaglebone-black-details.png" | absolute_url }})

The PRU is actually not as powerful as I've thought before. It has only 8KB program memory. In one of the test, I was trying to put an `sprintf` call into the PRU program, and the linker just refused to link it, because the program size is already greater than the limit. It is also quite hard to debug. In another test, I was trying to put the remoteproc buffer onto the stack, while running, it just hang the whole system up. I can do nothing but reboot the whole system. After several hours of debugging, I've noticed that, the remoteproc buffer has a size bigger than the PRU stack size, so once it is trying to allocate memory for the buffer, there is an stack overflow. But since the whole system hangs, I have no chance to know that.

I understand that the PRUs are not for programming a chat bot, so I think the main problem about PRU programming, or generally Beaglebone hardware is rather not less powerful than expected or hard to use, but an inactive community and eco-system. Despite its open-source nature, the technology looks like a commercial secret, and the hobbyists are trying hard to reverse-engineer it. Thus the information about the PRU programming and the Beaglebone hardware is distributed in several different places, which makes it almost impossible to get an overview on it.

The people in the #beagle IRC channel have helped me quite a lot. They actually managed to help me solve all of my problems that I have at that moment. But the main problem is still not solved. Yes, all my problems could be solved one by one if I ask the people in the IRC channel frequently enough. But I'm still playing a very passive role in the loop. When next problem comes, what I can do is blindly searching for the error message in Google and get nothing, and then go to the IRC channel, post my question and then wait for several hours, until someone noticed that and then answer the specific question. There will be always the next problem, what I need is the knowledge that the people have to help me solve the problem. But the knowledge they have is just like the alchemical ingredients, the "street knowledge" that the alchemists have gathered them for years. I don't hate the "street knowledge" actually. If I have time and the interests, I will also try to gather them, and publish them in a well-organized way in the Internet. But time and interests, neither I have at the moment. I have a project to build a drone, not to reverse-engineer a micro computer board.

Take a look at the release year of Beaglebone Black, 2013 it is. And the latest revision C.1 was released in the year of 2014. For almost 6 years, Beaglebone hasn't published any new credit-card sized micro computer. It doesn't like Raspberry Pi, who releases new models almost each 2 years. The short release circle might not help to build the highest quality hardware, but it does attract people to its community. In my opinion, the people in a lively community play the most important role in building a good eco-system. And indeed, I can always find information about almost all of the technical details about Raspberry Pi. All the documentations are well organized in its official website. Although it doesn't have anything comparable to PRU, for solving the "real-time" problem, I can always buy an extra hardware module which is compatible with Raspberry Pi, which make things much easier. For any questions, I don't even need to join the IRC channel. There are already dosens of people who have already run into the same problem before, I can always learn something from their experiences.

Finally, I decided to return the Beaglebone Black, putting it back to the box, and filling up the product returning sheet. Tomorrow, it will go back to where it comes. After that I've ordered Raspberry Pi 4B, which will become the new brain of the drone. Did I just wasted 5 days on the Beaglebone Black and doing nothing?

Well, I don't think so. At least half of the learning related to Beaglebone Black can be applied to Raspberry Pi. By playing around with Beaglebone Black, I've learnt what is `sysfs`, which is a virtual filesystem that allows people read/write data from/to hardware devices and provides a huge pile of information about them. And I've also got the feeling about how people are trying to map the control of the GPIO to a special memory address or a special register. Since I've graduated from the university, I've never touched anything about hardware programming again. And now, I've got a throwback to my university time. There is a flashing back in my head about all the slideshows and textbooks introducing the hardware programming knowledge. By applying the knowledge that I've learnt long time ago in the practises, I've got a lot of "aha" moments. It seems that, no time is wasted.
